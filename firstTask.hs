{-Следната функция „преплита“ елементите на списък с неговия гръбнак, 
така че когато най-външният конструктор бъде принуден да бъде активиран, 
елементът head също ще бъде активиран 
(освен ако списъкът не е празен, в който случай не се случва нищо допълнително):

forceElemsList :: [a] -> [a]
forceElemsList = foldr ((:) $!) []

Обърнете внимание, че forceElemsListне форсира гръбнака на аргумента си, 
а само гарантира, че когато някой потребител форсира гръбнака на списъка, 
върнат от forceElemsList, елементите на този списък също ще бъдат форсирани.

Можете ли да дефинирате функция, която прави същото, но за всяко Traversable?
 Т.е. функция със следната сигнатура на типа:

forceElems :: Traversable t => t a -> t a

Правила:

Tочно както forceElemsList, forceElemsне форсира spine-а на своя аргумент
(и следователно може да обработва безкрайни структури) , 
когато към него са прикачени елементи от типa (ако няма елементи от тип a, 
не се колебайте да форсирате този spine-ангажиран елемент, докато се появи елемент).

Допускат се контейнери с конструктори, съхраняващи множество елементи от тип a
(редът, в който те получават forces, няма значение) и множество рекурсивни събития.
няма нужда да се обработват странни персонализирани Traversable инстанции, 
които не са съгласни с DeriveTraversable(като например fmap idили (pure id <*>) извиквания,
 вмъкнати ръчно в средата на дефиницията на traverse)
Очаква се  forceElems да доведе до известни разходи за производителност, дори в сравнение с
forceElemsList

И има хардкор режим 
(изключен по подразбиране, променете hardcore = False на  hardcore = True за test/Main.hs
 да го включите)-}



{-# LANGUAGE ScopedTypeVariables #-}

module Lib
    ( forceElems
    , hardcore
    ) where

import Data.Traversable (Traversable(..))
import Data.Functor.Identity (Identity(..))

-- По подразбиране hardcore е изключен
hardcore :: Bool
hardcore = False

-- | forceElems: форсира всички елементи от тип 'a' в Traversable структура
--   без да засяга spine-а на структурата.
forceElems :: forall t a. Traversable t => t a -> t a
forceElems t
    | hardcore  = traverse forceHard t
    | otherwise = traverse ($!) t
  where
    -- В hardcore режим можем да сме по-предпазливи
    -- (пример: може да добавим проверки, че елементът е наистина от тип 'a')
    forceHard :: a -> a
    forceHard x = x $!  -- просто форсираме елемента, не spine-а
